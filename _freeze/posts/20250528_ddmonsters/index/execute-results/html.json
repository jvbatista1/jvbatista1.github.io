{
  "hash": "95a01aac91de5da2167570f6d5e467a2",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Dungeons & Dragons\"\ndescription: \"Quais tipos de monstro possuem as melhores habilidades?\"\nauthor:\n  - name: Victor Batista\n    url: https://jvbatista1.github.io/\n    langid: pt\ndate: 05/28/2025\ncategories: [Tidytuesday] # self-defined categories\ncitation: \n  url: https://jvbatista1.github.io/posts/20250528_ddmonsters/ \nimage: table.jpg\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\n---\n\nNo desafio do [Tidytuesday](https://github.com/rfordatascience/tidytuesday/blob/main/data/2025/2025-05-27/readme.md){target=\"_blank\"} foi apresentada uma base com os monstros de Dungeons and Dragons e seus atributos (stats). Uma das questões propostas é verificar quais tipos de monstros possuem os melhores scores.\n\nA solução que achei adequada para verificar rapidamente tanto os scores quanto o tipo de monstro foi criar um mapa de calor. Utilizando Seaborn e Matplotlib, cheguei ao resultado abaixo. O primeiro passo foi baixar a base e selecionar as variáveis de interesse:\n\n::: {#03da2e53 .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nmonsters = pd.read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/main/data/2025/2025-05-27/monsters.csv')\n\nattributes = ['str', 'dex', 'con', 'int', 'wis', 'cha']\ndf = monsters[['type'] + attributes]\n\nprint(df.isnull().sum())\n\n# df = df.dropna(subset=['type'] + attributes)\n\nsummary = df.groupby('type')[attributes].mean().reset_index()\nfreq = df['type'].value_counts().sort_index()\n\nprint(summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntype    0\nstr     0\ndex     0\ncon     0\nint     0\nwis     0\ncha     0\ndtype: int64\n                    type        str        dex        con        int  \\\n0             Aberration  16.333333  11.000000  14.555556   7.333333   \n1                  Beast  12.726190  12.976190  12.714286   2.202381   \n2              Celestial  17.923077  16.846154  16.923077  14.615385   \n3              Construct  17.000000  11.000000  16.000000   3.700000   \n4                 Dragon  21.622222  11.377778  20.044444  13.688889   \n5              Elemental  13.529412  13.529412  15.411765   9.294118   \n6                    Fey  12.733333  14.266667  12.400000  10.800000   \n7                  Fiend  16.275862  14.586207  16.448276  12.448276   \n8                  Giant  22.400000  10.600000  18.800000   8.100000   \n9               Humanoid  13.038462  13.346154  12.923077  11.384615   \n10           Monstrosity  16.891892  13.027027  16.135135   5.864865   \n11                  Ooze  14.250000   5.000000  16.500000   1.250000   \n12                 Plant  11.166667   5.333333  13.833333   6.500000   \n13  Swarm of Tiny Beasts   7.333333  14.500000  10.833333   2.000000   \n14  Swarm of Tiny Undead  14.000000  14.000000  11.000000   5.000000   \n15                Undead  12.333333  13.888889  14.277778   9.166667   \n\n          wis        cha  \n0   12.333333   7.111111  \n1   10.988095   5.083333  \n2   17.923077  16.692308  \n3    8.300000   2.800000  \n4   12.977778  17.400000  \n5   11.588235  10.705882  \n6   11.200000  11.200000  \n7   13.310345  14.482759  \n8   11.600000   9.700000  \n9   12.230769  12.269231  \n10  11.810811   8.594595  \n11   6.000000   1.250000  \n12   8.666667   5.333333  \n13   9.666667   3.166667  \n14  10.000000   4.000000  \n15  11.055556  10.555556  \n```\n:::\n:::\n\n\nMinhas escolhas de customização do gráfico (com ajuda do chat GPT, claro) foram:\n- Utilizar o `rcParams` pra configurar as fontes utilizadas\n- Dividir o gráfico em duas partes `(ax1, ax2)` para inserir um gráfico auxiliar, mostrando a frequencia dos monstros em cada tipo\n- Para um gráfico isolado, acho interessante utilizar uma outra cor de fundo que não seja branca\n\n::: {#40750cdc .cell execution_count=2}\n``` {.python .cell-code}\nsns.set_theme(style=\"whitegrid\")\nplt.rcParams.update({'font.size': 10, 'font.family': 'sans-serif', 'font.sans-serif': 'Tahoma'})\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 8),\n                               gridspec_kw={'width_ratios': [4, 1]}, sharey=True)\nfig.patch.set_facecolor('#fff8dc')  \n# Heatmap\nsns.heatmap(summary.set_index('type'),\n            annot=True, fmt=\".1f\",\n            cmap='bwr',\n            cbar=False,\n            annot_kws={\"size\":8, \"color\":\"black\"},\n            ax=ax1)\n\nax1.set_title('Average Ability Scores', fontsize=30, fontweight='bold', pad=15)\nax1.set_ylabel('Monster Type', fontsize=12)\nax1.set_xlabel('Ability Score', fontsize=12)\n\n# Barra de frequência\nax2.barh(freq.index, freq.values,\n         color='#888888',\n         edgecolor='black',\n         alpha=0.8)\n\nax2.set_title('Frequency', fontsize=16, fontweight='bold', pad=15)\nax2.set_xlabel('Count', fontsize=12)\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-3-output-1.png){}\n:::\n:::\n\n\nEssa é minha primeira experiência utilizando Python para um projeto pessoal. Tive um pouco de trabalho para configurar os chunks, uma vez que estou escrevendo este blog em Quarto, mas no fim deu tudo certo. As configurações do Seaborn são muito intuitivas para customização, embora eu tenha precisado de ajuda para lembrar todas elas direitinho.\n\nMeu objetivo, no futuro, é encontrar uma identidade visual para esses projetos que realizo como exercício. Existem projetos na comunidade que acho incríveis, como o [MEDS](https://bren.ucsb.edu/masters-programs/master-environmental-data-science) (que inclusive é a grande inpiração desse blog) e [Latinometrics](https://latinometrics.com). São sites muito bonitos e agradáveis de acompanhar, tanto pelas suas escolhas estéticas quanto pela alta qualidade das análises.\n\nSe eu conseguir chegar, pelo menos, perto do que eles fazem, já ficarei muito feliz!\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}